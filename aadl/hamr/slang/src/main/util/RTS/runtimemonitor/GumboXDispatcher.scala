// #Sireum

package RTS.runtimemonitor

import org.sireum._
import RTS._

// Do not edit this file as it will be overwritten if HAMR codegen is rerun

object GumboXDispatcher {
  def checkContract(observationKind: ObservationKind.Type, preContainer: Option[art.DataContent], postContainer: Option[art.DataContent]): B = {
    observationKind match {
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_instrumentationMock_instrumentationMockThread_postInit =>
        // checking the post-state values of instrumentationMockThread's initialise entrypoint is not required
        return T
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_instrumentationMock_instrumentationMockThread_preCompute =>
        // checking the pre-state values of instrumentationMockThread's compute entrypoint is not required
        return T
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_instrumentationMock_instrumentationMockThread_postCompute =>
        // checking the post-state values of instrumentationMockThread's compute entrypoint is not required
        return T

      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_eventControlMock_eventControlMockThread_postInit =>
        // checking the post-state values of eventControlMockThread's initialise entrypoint is not required
        return T
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_eventControlMock_eventControlMockThread_preCompute =>
        // checking the pre-state values of eventControlMockThread's compute entrypoint is not required
        return T
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_eventControlMock_eventControlMockThread_postCompute =>
        // checking the post-state values of eventControlMockThread's compute entrypoint is not required
        return T

      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuatorsMock_actuatorsMockThread_postInit =>
        // checking the post-state values of actuatorsMockThread's initialise entrypoint is not required
        return T
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuatorsMock_actuatorsMockThread_preCompute =>
        // checking the pre-state values of actuatorsMockThread's compute entrypoint is not required
        return T
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuatorsMock_actuatorsMockThread_postCompute =>
        // checking the post-state values of actuatorsMockThread's compute entrypoint is not required
        return T

      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_postInit =>
        // checking the post-state values of coincidenceLogic's initialise entrypoint is not required
        return T
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_preCompute =>
        // checking the pre-state values of coincidenceLogic's compute entrypoint is not required
        return T
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_postCompute =>
        val result: B = RTS.Actuation.CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_GumboX.compute_CEP_Post_Container(preContainer.get.asInstanceOf[RTS.Actuation.CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_PreState_Container_PS], postContainer.get.asInstanceOf[RTS.Actuation.CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_PostState_Container_PS])
        //println(s"coincidenceLogic.timeTriggered: Post-condition: ${if (result) "" else "un"}satisfied")
        return result

      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_postInit =>
        // checking the post-state values of coincidenceLogic's initialise entrypoint is not required
        return T
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_preCompute =>
        // checking the pre-state values of coincidenceLogic's compute entrypoint is not required
        return T
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_postCompute =>
        val result: B = RTS.Actuation.CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_GumboX.compute_CEP_Post_Container(preContainer.get.asInstanceOf[RTS.Actuation.CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_PreState_Container_PS], postContainer.get.asInstanceOf[RTS.Actuation.CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_PostState_Container_PS])
        //println(s"coincidenceLogic.timeTriggered: Post-condition: ${if (result) "" else "un"}satisfied")
        return result

      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_postInit =>
        // checking the post-state values of coincidenceLogic's initialise entrypoint is not required
        return T
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_preCompute =>
        // checking the pre-state values of coincidenceLogic's compute entrypoint is not required
        return T
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_postCompute =>
        val result: B = RTS.Actuation.CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_GumboX.compute_CEP_Post_Container(preContainer.get.asInstanceOf[RTS.Actuation.CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_PreState_Container_PS], postContainer.get.asInstanceOf[RTS.Actuation.CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_PostState_Container_PS])
        //println(s"coincidenceLogic.timeTriggered: Post-condition: ${if (result) "" else "un"}satisfied")
        return result

      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_postInit =>
        // checking the post-state values of orLogic's initialise entrypoint is not required
        return T
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_preCompute =>
        // checking the pre-state values of orLogic's compute entrypoint is not required
        return T
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_postCompute =>
        val result: B = RTS.Actuation.OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_GumboX.compute_CEP_Post_Container(preContainer.get.asInstanceOf[RTS.Actuation.OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_PreState_Container_PS], postContainer.get.asInstanceOf[RTS.Actuation.OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_PostState_Container_PS])
        //println(s"orLogic.timeTriggered: Post-condition: ${if (result) "" else "un"}satisfied")
        return result

      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_postInit =>
        // checking the post-state values of coincidenceLogic's initialise entrypoint is not required
        return T
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_preCompute =>
        // checking the pre-state values of coincidenceLogic's compute entrypoint is not required
        return T
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_postCompute =>
        val result: B = RTS.Actuation.CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_GumboX.compute_CEP_Post_Container(preContainer.get.asInstanceOf[RTS.Actuation.CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_PreState_Container_PS], postContainer.get.asInstanceOf[RTS.Actuation.CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_PostState_Container_PS])
        //println(s"coincidenceLogic.timeTriggered: Post-condition: ${if (result) "" else "un"}satisfied")
        return result

      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_postInit =>
        // checking the post-state values of coincidenceLogic's initialise entrypoint is not required
        return T
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_preCompute =>
        // checking the pre-state values of coincidenceLogic's compute entrypoint is not required
        return T
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_postCompute =>
        val result: B = RTS.Actuation.CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_GumboX.compute_CEP_Post_Container(preContainer.get.asInstanceOf[RTS.Actuation.CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_PreState_Container_PS], postContainer.get.asInstanceOf[RTS.Actuation.CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_PostState_Container_PS])
        //println(s"coincidenceLogic.timeTriggered: Post-condition: ${if (result) "" else "un"}satisfied")
        return result

      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_postInit =>
        // checking the post-state values of coincidenceLogic's initialise entrypoint is not required
        return T
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_preCompute =>
        // checking the pre-state values of coincidenceLogic's compute entrypoint is not required
        return T
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_postCompute =>
        val result: B = RTS.Actuation.CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_GumboX.compute_CEP_Post_Container(preContainer.get.asInstanceOf[RTS.Actuation.CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_PreState_Container_PS], postContainer.get.asInstanceOf[RTS.Actuation.CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_PostState_Container_PS])
        //println(s"coincidenceLogic.timeTriggered: Post-condition: ${if (result) "" else "un"}satisfied")
        return result

      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_postInit =>
        // checking the post-state values of orLogic's initialise entrypoint is not required
        return T
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_preCompute =>
        // checking the pre-state values of orLogic's compute entrypoint is not required
        return T
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_postCompute =>
        val result: B = RTS.Actuation.OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_GumboX.compute_CEP_Post_Container(preContainer.get.asInstanceOf[RTS.Actuation.OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_PreState_Container_PS], postContainer.get.asInstanceOf[RTS.Actuation.OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_PostState_Container_PS])
        //println(s"orLogic.timeTriggered: Post-condition: ${if (result) "" else "un"}satisfied")
        return result

      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_postInit =>
        // checking the post-state values of orLogic's initialise entrypoint is not required
        return T
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_preCompute =>
        // checking the pre-state values of orLogic's compute entrypoint is not required
        return T
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_postCompute =>
        val result: B = RTS.Actuation.OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_GumboX.compute_CEP_Post_Container(preContainer.get.asInstanceOf[RTS.Actuation.OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_PreState_Container_PS], postContainer.get.asInstanceOf[RTS.Actuation.OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_PostState_Container_PS])
        //println(s"orLogic.timeTriggered: Post-condition: ${if (result) "" else "un"}satisfied")
        return result

      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_postInit =>
        val result: B = RTS.Actuation.Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_GumboX.inititialize_IEP_Post_Container(postContainer.get.asInstanceOf[RTS.Actuation.Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_PostState_Container_PS])
        //println(s"actuator.initialise: Post-condition: ${if (result) "" else "un"}satisfied")
        return result
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_preCompute =>
        // checking the pre-state values of actuator's compute entrypoint is not required
        return T
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_postCompute =>
        val result: B = RTS.Actuation.Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_GumboX.compute_CEP_Post_Container(preContainer.get.asInstanceOf[RTS.Actuation.Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_PreState_Container_PS], postContainer.get.asInstanceOf[RTS.Actuation.Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_PostState_Container_PS])
        //println(s"actuator.timeTriggered: Post-condition: ${if (result) "" else "un"}satisfied")
        return result

      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_postInit =>
        // checking the post-state values of orLogic's initialise entrypoint is not required
        return T
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_preCompute =>
        // checking the pre-state values of orLogic's compute entrypoint is not required
        return T
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_postCompute =>
        val result: B = RTS.Actuation.OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_GumboX.compute_CEP_Post_Container(preContainer.get.asInstanceOf[RTS.Actuation.OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_PreState_Container_PS], postContainer.get.asInstanceOf[RTS.Actuation.OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_PostState_Container_PS])
        //println(s"orLogic.timeTriggered: Post-condition: ${if (result) "" else "un"}satisfied")
        return result

      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_postInit =>
        val result: B = RTS.Actuation.Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_GumboX.inititialize_IEP_Post_Container(postContainer.get.asInstanceOf[RTS.Actuation.Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_PostState_Container_PS])
        //println(s"actuator.initialise: Post-condition: ${if (result) "" else "un"}satisfied")
        return result
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_preCompute =>
        // checking the pre-state values of actuator's compute entrypoint is not required
        return T
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_postCompute =>
        val result: B = RTS.Actuation.Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_GumboX.compute_CEP_Post_Container(preContainer.get.asInstanceOf[RTS.Actuation.Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_PreState_Container_PS], postContainer.get.asInstanceOf[RTS.Actuation.Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_PostState_Container_PS])
        //println(s"actuator.timeTriggered: Post-condition: ${if (result) "" else "un"}satisfied")
        return result

      case _ => halt("Infeasible")
    }
  }

  def genTestSuite(testCases: ISZ[(Z, ISZ[ST])]): Unit = {
    val tq = "\"\"\""

    val testRoot = Os.path(".") / "src" / "test" / "bridge"

    val InstrumentationMockThread_i_instrumentationMock_instrumentationMockThread_id = Arch.RTS_i_Instance_instrumentationMock_instrumentationMockThread.id
    val EventControlMockThread_i_eventControlMock_eventControlMockThread_id = Arch.RTS_i_Instance_eventControlMock_eventControlMockThread.id
    val ActuatorsMockThread_i_actuatorsMock_actuatorsMockThread_id = Arch.RTS_i_Instance_actuatorsMock_actuatorsMockThread.id
    val CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_id = Arch.RTS_i_Instance_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic.id
    val CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_id = Arch.RTS_i_Instance_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic.id
    val CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_id = Arch.RTS_i_Instance_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic.id
    val OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_id = Arch.RTS_i_Instance_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic.id
    val CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_id = Arch.RTS_i_Instance_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic.id
    val CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_id = Arch.RTS_i_Instance_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic.id
    val CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_id = Arch.RTS_i_Instance_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic.id
    val OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_id = Arch.RTS_i_Instance_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic.id
    val OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_id = Arch.RTS_i_Instance_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic.id
    val Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_id = Arch.RTS_i_Instance_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator.id
    val OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_id = Arch.RTS_i_Instance_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic.id
    val Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_id = Arch.RTS_i_Instance_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator.id

    def genUniqueSuiteName(path: Os.Path, prefix: String): String = {
      var i = 0
      while(true) {
        val cand = path / s"${prefix}_${i}.scala"
        if (!cand.exists) {
          return s"${prefix}_${i}"
        }
        i = i + 1
      }
      halt("Infeasible")
    }

    for (p <- testCases) {
      art.Art.BridgeId.fromZ(p._1) match {
        case InstrumentationMockThread_i_instrumentationMock_instrumentationMockThread_id =>
          val prefix = "InstrumentationMockThread_i_instrumentationMock_instrumentationMockThread_RM_TestSuite"
          val path = testRoot /+ ISZ("RTS","Instrumentation")
          val suiteName = genUniqueSuiteName(path, prefix)

          val testSuite =
            st"""package RTS.Instrumentation
                |
                |import org.sireum._
                |import RTS.Instrumentation._
                |
                |class ${suiteName} extends InstrumentationMockThread_i_instrumentationMock_instrumentationMockThread_GumboX_TestHarness_ScalaTest {
                |  val verbose: B = true
                |
                |  var i = 0 // ensures generated test case names are unique
                |  def incrementI: Int = {
                |    i += 1
                |    return i
                |  }
                |
                |  ${(p._2, "\nincrementI\n\n")}
                |}"""
          val filename = path / s"${suiteName}.scala"
          filename.writeOver(testSuite.render)
          println(s"Wrote: ${filename.toUri}")
        case EventControlMockThread_i_eventControlMock_eventControlMockThread_id =>
          val prefix = "EventControlMockThread_i_eventControlMock_eventControlMockThread_RM_TestSuite"
          val path = testRoot /+ ISZ("RTS","EventControl")
          val suiteName = genUniqueSuiteName(path, prefix)

          val testSuite =
            st"""package RTS.EventControl
                |
                |import org.sireum._
                |import RTS.EventControl._
                |
                |class ${suiteName} extends EventControlMockThread_i_eventControlMock_eventControlMockThread_GumboX_TestHarness_ScalaTest {
                |  val verbose: B = true
                |
                |  var i = 0 // ensures generated test case names are unique
                |  def incrementI: Int = {
                |    i += 1
                |    return i
                |  }
                |
                |  ${(p._2, "\nincrementI\n\n")}
                |}"""
          val filename = path / s"${suiteName}.scala"
          filename.writeOver(testSuite.render)
          println(s"Wrote: ${filename.toUri}")
        case ActuatorsMockThread_i_actuatorsMock_actuatorsMockThread_id =>
          val prefix = "ActuatorsMockThread_i_actuatorsMock_actuatorsMockThread_RM_TestSuite"
          val path = testRoot /+ ISZ("RTS","Actuators")
          val suiteName = genUniqueSuiteName(path, prefix)

          val testSuite =
            st"""package RTS.Actuators
                |
                |import org.sireum._
                |import RTS.Actuators._
                |
                |class ${suiteName} extends ActuatorsMockThread_i_actuatorsMock_actuatorsMockThread_GumboX_TestHarness_ScalaTest {
                |  val verbose: B = true
                |
                |  var i = 0 // ensures generated test case names are unique
                |  def incrementI: Int = {
                |    i += 1
                |    return i
                |  }
                |
                |  ${(p._2, "\nincrementI\n\n")}
                |}"""
          val filename = path / s"${suiteName}.scala"
          filename.writeOver(testSuite.render)
          println(s"Wrote: ${filename.toUri}")
        case CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_id =>
          val prefix = "CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_RM_TestSuite"
          val path = testRoot /+ ISZ("RTS","Actuation")
          val suiteName = genUniqueSuiteName(path, prefix)

          val testSuite =
            st"""package RTS.Actuation
                |
                |import org.sireum._
                |import RTS.Actuation._
                |
                |class ${suiteName} extends CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_GumboX_TestHarness_ScalaTest {
                |  val verbose: B = true
                |
                |  var i = 0 // ensures generated test case names are unique
                |  def incrementI: Int = {
                |    i += 1
                |    return i
                |  }
                |
                |  ${(p._2, "\nincrementI\n\n")}
                |}"""
          val filename = path / s"${suiteName}.scala"
          filename.writeOver(testSuite.render)
          println(s"Wrote: ${filename.toUri}")
        case CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_id =>
          val prefix = "CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_RM_TestSuite"
          val path = testRoot /+ ISZ("RTS","Actuation")
          val suiteName = genUniqueSuiteName(path, prefix)

          val testSuite =
            st"""package RTS.Actuation
                |
                |import org.sireum._
                |import RTS.Actuation._
                |
                |class ${suiteName} extends CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_GumboX_TestHarness_ScalaTest {
                |  val verbose: B = true
                |
                |  var i = 0 // ensures generated test case names are unique
                |  def incrementI: Int = {
                |    i += 1
                |    return i
                |  }
                |
                |  ${(p._2, "\nincrementI\n\n")}
                |}"""
          val filename = path / s"${suiteName}.scala"
          filename.writeOver(testSuite.render)
          println(s"Wrote: ${filename.toUri}")
        case CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_id =>
          val prefix = "CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_RM_TestSuite"
          val path = testRoot /+ ISZ("RTS","Actuation")
          val suiteName = genUniqueSuiteName(path, prefix)

          val testSuite =
            st"""package RTS.Actuation
                |
                |import org.sireum._
                |import RTS.Actuation._
                |
                |class ${suiteName} extends CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_GumboX_TestHarness_ScalaTest {
                |  val verbose: B = true
                |
                |  var i = 0 // ensures generated test case names are unique
                |  def incrementI: Int = {
                |    i += 1
                |    return i
                |  }
                |
                |  ${(p._2, "\nincrementI\n\n")}
                |}"""
          val filename = path / s"${suiteName}.scala"
          filename.writeOver(testSuite.render)
          println(s"Wrote: ${filename.toUri}")
        case OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_id =>
          val prefix = "OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_RM_TestSuite"
          val path = testRoot /+ ISZ("RTS","Actuation")
          val suiteName = genUniqueSuiteName(path, prefix)

          val testSuite =
            st"""package RTS.Actuation
                |
                |import org.sireum._
                |import RTS.Actuation._
                |
                |class ${suiteName} extends OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_GumboX_TestHarness_ScalaTest {
                |  val verbose: B = true
                |
                |  var i = 0 // ensures generated test case names are unique
                |  def incrementI: Int = {
                |    i += 1
                |    return i
                |  }
                |
                |  ${(p._2, "\nincrementI\n\n")}
                |}"""
          val filename = path / s"${suiteName}.scala"
          filename.writeOver(testSuite.render)
          println(s"Wrote: ${filename.toUri}")
        case CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_id =>
          val prefix = "CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_RM_TestSuite"
          val path = testRoot /+ ISZ("RTS","Actuation")
          val suiteName = genUniqueSuiteName(path, prefix)

          val testSuite =
            st"""package RTS.Actuation
                |
                |import org.sireum._
                |import RTS.Actuation._
                |
                |class ${suiteName} extends CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_GumboX_TestHarness_ScalaTest {
                |  val verbose: B = true
                |
                |  var i = 0 // ensures generated test case names are unique
                |  def incrementI: Int = {
                |    i += 1
                |    return i
                |  }
                |
                |  ${(p._2, "\nincrementI\n\n")}
                |}"""
          val filename = path / s"${suiteName}.scala"
          filename.writeOver(testSuite.render)
          println(s"Wrote: ${filename.toUri}")
        case CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_id =>
          val prefix = "CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_RM_TestSuite"
          val path = testRoot /+ ISZ("RTS","Actuation")
          val suiteName = genUniqueSuiteName(path, prefix)

          val testSuite =
            st"""package RTS.Actuation
                |
                |import org.sireum._
                |import RTS.Actuation._
                |
                |class ${suiteName} extends CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_GumboX_TestHarness_ScalaTest {
                |  val verbose: B = true
                |
                |  var i = 0 // ensures generated test case names are unique
                |  def incrementI: Int = {
                |    i += 1
                |    return i
                |  }
                |
                |  ${(p._2, "\nincrementI\n\n")}
                |}"""
          val filename = path / s"${suiteName}.scala"
          filename.writeOver(testSuite.render)
          println(s"Wrote: ${filename.toUri}")
        case CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_id =>
          val prefix = "CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_RM_TestSuite"
          val path = testRoot /+ ISZ("RTS","Actuation")
          val suiteName = genUniqueSuiteName(path, prefix)

          val testSuite =
            st"""package RTS.Actuation
                |
                |import org.sireum._
                |import RTS.Actuation._
                |
                |class ${suiteName} extends CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_GumboX_TestHarness_ScalaTest {
                |  val verbose: B = true
                |
                |  var i = 0 // ensures generated test case names are unique
                |  def incrementI: Int = {
                |    i += 1
                |    return i
                |  }
                |
                |  ${(p._2, "\nincrementI\n\n")}
                |}"""
          val filename = path / s"${suiteName}.scala"
          filename.writeOver(testSuite.render)
          println(s"Wrote: ${filename.toUri}")
        case OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_id =>
          val prefix = "OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_RM_TestSuite"
          val path = testRoot /+ ISZ("RTS","Actuation")
          val suiteName = genUniqueSuiteName(path, prefix)

          val testSuite =
            st"""package RTS.Actuation
                |
                |import org.sireum._
                |import RTS.Actuation._
                |
                |class ${suiteName} extends OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_GumboX_TestHarness_ScalaTest {
                |  val verbose: B = true
                |
                |  var i = 0 // ensures generated test case names are unique
                |  def incrementI: Int = {
                |    i += 1
                |    return i
                |  }
                |
                |  ${(p._2, "\nincrementI\n\n")}
                |}"""
          val filename = path / s"${suiteName}.scala"
          filename.writeOver(testSuite.render)
          println(s"Wrote: ${filename.toUri}")
        case OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_id =>
          val prefix = "OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_RM_TestSuite"
          val path = testRoot /+ ISZ("RTS","Actuation")
          val suiteName = genUniqueSuiteName(path, prefix)

          val testSuite =
            st"""package RTS.Actuation
                |
                |import org.sireum._
                |import RTS.Actuation._
                |
                |class ${suiteName} extends OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_GumboX_TestHarness_ScalaTest {
                |  val verbose: B = true
                |
                |  var i = 0 // ensures generated test case names are unique
                |  def incrementI: Int = {
                |    i += 1
                |    return i
                |  }
                |
                |  ${(p._2, "\nincrementI\n\n")}
                |}"""
          val filename = path / s"${suiteName}.scala"
          filename.writeOver(testSuite.render)
          println(s"Wrote: ${filename.toUri}")
        case Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_id =>
          val prefix = "Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_RM_TestSuite"
          val path = testRoot /+ ISZ("RTS","Actuation")
          val suiteName = genUniqueSuiteName(path, prefix)

          val testSuite =
            st"""package RTS.Actuation
                |
                |import org.sireum._
                |import RTS.Actuation._
                |
                |class ${suiteName} extends Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_GumboX_TestHarness_ScalaTest {
                |  val verbose: B = true
                |
                |  var i = 0 // ensures generated test case names are unique
                |  def incrementI: Int = {
                |    i += 1
                |    return i
                |  }
                |
                |  ${(p._2, "\nincrementI\n\n")}
                |}"""
          val filename = path / s"${suiteName}.scala"
          filename.writeOver(testSuite.render)
          println(s"Wrote: ${filename.toUri}")
        case OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_id =>
          val prefix = "OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_RM_TestSuite"
          val path = testRoot /+ ISZ("RTS","Actuation")
          val suiteName = genUniqueSuiteName(path, prefix)

          val testSuite =
            st"""package RTS.Actuation
                |
                |import org.sireum._
                |import RTS.Actuation._
                |
                |class ${suiteName} extends OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_GumboX_TestHarness_ScalaTest {
                |  val verbose: B = true
                |
                |  var i = 0 // ensures generated test case names are unique
                |  def incrementI: Int = {
                |    i += 1
                |    return i
                |  }
                |
                |  ${(p._2, "\nincrementI\n\n")}
                |}"""
          val filename = path / s"${suiteName}.scala"
          filename.writeOver(testSuite.render)
          println(s"Wrote: ${filename.toUri}")
        case Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_id =>
          val prefix = "Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_RM_TestSuite"
          val path = testRoot /+ ISZ("RTS","Actuation")
          val suiteName = genUniqueSuiteName(path, prefix)

          val testSuite =
            st"""package RTS.Actuation
                |
                |import org.sireum._
                |import RTS.Actuation._
                |
                |class ${suiteName} extends Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_GumboX_TestHarness_ScalaTest {
                |  val verbose: B = true
                |
                |  var i = 0 // ensures generated test case names are unique
                |  def incrementI: Int = {
                |    i += 1
                |    return i
                |  }
                |
                |  ${(p._2, "\nincrementI\n\n")}
                |}"""
          val filename = path / s"${suiteName}.scala"
          filename.writeOver(testSuite.render)
          println(s"Wrote: ${filename.toUri}")
        case x => halt(s"Infeasible bridge id: $x")
      }
    }
  }

  def genTestCase(observationKind: ObservationKind.Type, preContainer: Option[String], postContainer: Option[String], testNameSuffix: Option[String]): ST = {
    val tq = "\"\"\""
    val suffix: String =
      if (testNameSuffix.nonEmpty) testNameSuffix.get
      else ""

    observationKind match {



      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_postCompute =>
        return (st"""// Begin test cases for RTS_i_Instance_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_postCompute
                    |
                    |test(s"RTS_i_Instance_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_postCompute: Check Post-condition$suffix") {
                    |  val preJson: String = st${tq}${preContainer.get}${tq}.render
                    |  val postJson: String = st${tq}${postContainer.get}${tq}.render
                    |  val preContainer = RTS.JSON.toActuationCoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_PreState_Container_PS(preJson).left
                    |  val postContainer = RTS.JSON.toActuationCoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_PostState_Container_PS(postJson).left
                    |  if (verbose) {
                    |    println("Pre-State Values:")
                    |    println(s"  $$preContainer")
                    |    println("Post-State Values:")
                    |    println(s"  $$postContainer");
                    |  }
                    |  assert(RTS.Actuation.CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_GumboX.compute_CEP_Post_Container(preContainer, postContainer))
                    |}
                    |// End test cases for RTS_i_Instance_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_postCompute""")
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_postCompute =>
        return (st"""// Begin test cases for RTS_i_Instance_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_postCompute
                    |
                    |test(s"RTS_i_Instance_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_postCompute: Check Post-condition$suffix") {
                    |  val preJson: String = st${tq}${preContainer.get}${tq}.render
                    |  val postJson: String = st${tq}${postContainer.get}${tq}.render
                    |  val preContainer = RTS.JSON.toActuationCoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_PreState_Container_PS(preJson).left
                    |  val postContainer = RTS.JSON.toActuationCoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_PostState_Container_PS(postJson).left
                    |  if (verbose) {
                    |    println("Pre-State Values:")
                    |    println(s"  $$preContainer")
                    |    println("Post-State Values:")
                    |    println(s"  $$postContainer");
                    |  }
                    |  assert(RTS.Actuation.CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_GumboX.compute_CEP_Post_Container(preContainer, postContainer))
                    |}
                    |// End test cases for RTS_i_Instance_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_postCompute""")
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_postCompute =>
        return (st"""// Begin test cases for RTS_i_Instance_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_postCompute
                    |
                    |test(s"RTS_i_Instance_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_postCompute: Check Post-condition$suffix") {
                    |  val preJson: String = st${tq}${preContainer.get}${tq}.render
                    |  val postJson: String = st${tq}${postContainer.get}${tq}.render
                    |  val preContainer = RTS.JSON.toActuationCoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_PreState_Container_PS(preJson).left
                    |  val postContainer = RTS.JSON.toActuationCoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_PostState_Container_PS(postJson).left
                    |  if (verbose) {
                    |    println("Pre-State Values:")
                    |    println(s"  $$preContainer")
                    |    println("Post-State Values:")
                    |    println(s"  $$postContainer");
                    |  }
                    |  assert(RTS.Actuation.CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_GumboX.compute_CEP_Post_Container(preContainer, postContainer))
                    |}
                    |// End test cases for RTS_i_Instance_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_postCompute""")
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_postCompute =>
        return (st"""// Begin test cases for RTS_i_Instance_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_postCompute
                    |
                    |test(s"RTS_i_Instance_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_postCompute: Check Post-condition$suffix") {
                    |  val preJson: String = st${tq}${preContainer.get}${tq}.render
                    |  val postJson: String = st${tq}${postContainer.get}${tq}.render
                    |  val preContainer = RTS.JSON.toActuationOrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_PreState_Container_PS(preJson).left
                    |  val postContainer = RTS.JSON.toActuationOrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_PostState_Container_PS(postJson).left
                    |  if (verbose) {
                    |    println("Pre-State Values:")
                    |    println(s"  $$preContainer")
                    |    println("Post-State Values:")
                    |    println(s"  $$postContainer");
                    |  }
                    |  assert(RTS.Actuation.OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_GumboX.compute_CEP_Post_Container(preContainer, postContainer))
                    |}
                    |// End test cases for RTS_i_Instance_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_postCompute""")
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_postCompute =>
        return (st"""// Begin test cases for RTS_i_Instance_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_postCompute
                    |
                    |test(s"RTS_i_Instance_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_postCompute: Check Post-condition$suffix") {
                    |  val preJson: String = st${tq}${preContainer.get}${tq}.render
                    |  val postJson: String = st${tq}${postContainer.get}${tq}.render
                    |  val preContainer = RTS.JSON.toActuationCoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_PreState_Container_PS(preJson).left
                    |  val postContainer = RTS.JSON.toActuationCoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_PostState_Container_PS(postJson).left
                    |  if (verbose) {
                    |    println("Pre-State Values:")
                    |    println(s"  $$preContainer")
                    |    println("Post-State Values:")
                    |    println(s"  $$postContainer");
                    |  }
                    |  assert(RTS.Actuation.CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_GumboX.compute_CEP_Post_Container(preContainer, postContainer))
                    |}
                    |// End test cases for RTS_i_Instance_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_postCompute""")
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_postCompute =>
        return (st"""// Begin test cases for RTS_i_Instance_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_postCompute
                    |
                    |test(s"RTS_i_Instance_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_postCompute: Check Post-condition$suffix") {
                    |  val preJson: String = st${tq}${preContainer.get}${tq}.render
                    |  val postJson: String = st${tq}${postContainer.get}${tq}.render
                    |  val preContainer = RTS.JSON.toActuationCoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_PreState_Container_PS(preJson).left
                    |  val postContainer = RTS.JSON.toActuationCoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_PostState_Container_PS(postJson).left
                    |  if (verbose) {
                    |    println("Pre-State Values:")
                    |    println(s"  $$preContainer")
                    |    println("Post-State Values:")
                    |    println(s"  $$postContainer");
                    |  }
                    |  assert(RTS.Actuation.CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_GumboX.compute_CEP_Post_Container(preContainer, postContainer))
                    |}
                    |// End test cases for RTS_i_Instance_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_postCompute""")
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_postCompute =>
        return (st"""// Begin test cases for RTS_i_Instance_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_postCompute
                    |
                    |test(s"RTS_i_Instance_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_postCompute: Check Post-condition$suffix") {
                    |  val preJson: String = st${tq}${preContainer.get}${tq}.render
                    |  val postJson: String = st${tq}${postContainer.get}${tq}.render
                    |  val preContainer = RTS.JSON.toActuationCoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_PreState_Container_PS(preJson).left
                    |  val postContainer = RTS.JSON.toActuationCoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_PostState_Container_PS(postJson).left
                    |  if (verbose) {
                    |    println("Pre-State Values:")
                    |    println(s"  $$preContainer")
                    |    println("Post-State Values:")
                    |    println(s"  $$postContainer");
                    |  }
                    |  assert(RTS.Actuation.CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_GumboX.compute_CEP_Post_Container(preContainer, postContainer))
                    |}
                    |// End test cases for RTS_i_Instance_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_postCompute""")
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_postCompute =>
        return (st"""// Begin test cases for RTS_i_Instance_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_postCompute
                    |
                    |test(s"RTS_i_Instance_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_postCompute: Check Post-condition$suffix") {
                    |  val preJson: String = st${tq}${preContainer.get}${tq}.render
                    |  val postJson: String = st${tq}${postContainer.get}${tq}.render
                    |  val preContainer = RTS.JSON.toActuationOrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_PreState_Container_PS(preJson).left
                    |  val postContainer = RTS.JSON.toActuationOrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_PostState_Container_PS(postJson).left
                    |  if (verbose) {
                    |    println("Pre-State Values:")
                    |    println(s"  $$preContainer")
                    |    println("Post-State Values:")
                    |    println(s"  $$postContainer");
                    |  }
                    |  assert(RTS.Actuation.OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_GumboX.compute_CEP_Post_Container(preContainer, postContainer))
                    |}
                    |// End test cases for RTS_i_Instance_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_postCompute""")
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_postCompute =>
        return (st"""// Begin test cases for RTS_i_Instance_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_postCompute
                    |
                    |test(s"RTS_i_Instance_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_postCompute: Check Post-condition$suffix") {
                    |  val preJson: String = st${tq}${preContainer.get}${tq}.render
                    |  val postJson: String = st${tq}${postContainer.get}${tq}.render
                    |  val preContainer = RTS.JSON.toActuationOrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_PreState_Container_PS(preJson).left
                    |  val postContainer = RTS.JSON.toActuationOrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_PostState_Container_PS(postJson).left
                    |  if (verbose) {
                    |    println("Pre-State Values:")
                    |    println(s"  $$preContainer")
                    |    println("Post-State Values:")
                    |    println(s"  $$postContainer");
                    |  }
                    |  assert(RTS.Actuation.OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_GumboX.compute_CEP_Post_Container(preContainer, postContainer))
                    |}
                    |// End test cases for RTS_i_Instance_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_postCompute""")
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_postInit =>
        return (st"""// Begin test cases for RTS_i_Instance_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_postInit
                    |
                    |test(s"RTS_i_Instance_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_postInit: Check Post-condition$suffix") {
                    |  val postJson: String = st${tq}${postContainer.get}${tq}.render
                    |  val postContainer = RTS.JSON.toActuationActuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_PostState_Container_PS(postJson).left
                    |  assert(RTS.Actuation.Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_GumboX.inititialize_IEP_Post_Container(postContainer))
                    |}
                    |// End test cases for RTS_i_Instance_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_postInit""")
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_postCompute =>
        return (st"""// Begin test cases for RTS_i_Instance_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_postCompute
                    |
                    |test(s"RTS_i_Instance_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_postCompute: Check Post-condition$suffix") {
                    |  val preJson: String = st${tq}${preContainer.get}${tq}.render
                    |  val postJson: String = st${tq}${postContainer.get}${tq}.render
                    |  val preContainer = RTS.JSON.toActuationActuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_PreState_Container_PS(preJson).left
                    |  val postContainer = RTS.JSON.toActuationActuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_PostState_Container_PS(postJson).left
                    |  if (verbose) {
                    |    println("Pre-State Values:")
                    |    println(s"  $$preContainer")
                    |    println("Post-State Values:")
                    |    println(s"  $$postContainer");
                    |  }
                    |  assert(RTS.Actuation.Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_GumboX.compute_CEP_Post_Container(preContainer, postContainer))
                    |}
                    |// End test cases for RTS_i_Instance_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_postCompute""")
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_postCompute =>
        return (st"""// Begin test cases for RTS_i_Instance_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_postCompute
                    |
                    |test(s"RTS_i_Instance_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_postCompute: Check Post-condition$suffix") {
                    |  val preJson: String = st${tq}${preContainer.get}${tq}.render
                    |  val postJson: String = st${tq}${postContainer.get}${tq}.render
                    |  val preContainer = RTS.JSON.toActuationOrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_PreState_Container_PS(preJson).left
                    |  val postContainer = RTS.JSON.toActuationOrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_PostState_Container_PS(postJson).left
                    |  if (verbose) {
                    |    println("Pre-State Values:")
                    |    println(s"  $$preContainer")
                    |    println("Post-State Values:")
                    |    println(s"  $$postContainer");
                    |  }
                    |  assert(RTS.Actuation.OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_GumboX.compute_CEP_Post_Container(preContainer, postContainer))
                    |}
                    |// End test cases for RTS_i_Instance_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_postCompute""")
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_postInit =>
        return (st"""// Begin test cases for RTS_i_Instance_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_postInit
                    |
                    |test(s"RTS_i_Instance_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_postInit: Check Post-condition$suffix") {
                    |  val postJson: String = st${tq}${postContainer.get}${tq}.render
                    |  val postContainer = RTS.JSON.toActuationActuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_PostState_Container_PS(postJson).left
                    |  assert(RTS.Actuation.Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_GumboX.inititialize_IEP_Post_Container(postContainer))
                    |}
                    |// End test cases for RTS_i_Instance_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_postInit""")
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_postCompute =>
        return (st"""// Begin test cases for RTS_i_Instance_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_postCompute
                    |
                    |test(s"RTS_i_Instance_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_postCompute: Check Post-condition$suffix") {
                    |  val preJson: String = st${tq}${preContainer.get}${tq}.render
                    |  val postJson: String = st${tq}${postContainer.get}${tq}.render
                    |  val preContainer = RTS.JSON.toActuationActuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_PreState_Container_PS(preJson).left
                    |  val postContainer = RTS.JSON.toActuationActuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_PostState_Container_PS(postJson).left
                    |  if (verbose) {
                    |    println("Pre-State Values:")
                    |    println(s"  $$preContainer")
                    |    println("Post-State Values:")
                    |    println(s"  $$postContainer");
                    |  }
                    |  assert(RTS.Actuation.Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_GumboX.compute_CEP_Post_Container(preContainer, postContainer))
                    |}
                    |// End test cases for RTS_i_Instance_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_postCompute""")
      case _ => return st"// TODO ${observationKind}"
    }
  }

  def getUpdates(bridge_id: art.Art.BridgeId, observationKind: ObservationKind.Type, container: art.DataContent): Map[String, String] = {
    observationKind match {
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_instrumentationMock_instrumentationMockThread_postInit =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[RTS.Instrumentation.InstrumentationMockThread_i_instrumentationMock_instrumentationMockThread_PostState_Container_PS]
        updates = updates + s"${bridge_id}_Out_unit1_temperatureLogic_channel1" ~> postContainer.api_unit1_temperatureLogic_channel1.string
        updates = updates + s"${bridge_id}_Out_unit1_temperatureLogic_channel2" ~> postContainer.api_unit1_temperatureLogic_channel2.string
        updates = updates + s"${bridge_id}_Out_unit1_temperatureLogic_channel3" ~> postContainer.api_unit1_temperatureLogic_channel3.string
        updates = updates + s"${bridge_id}_Out_unit1_temperatureLogic_channel4" ~> postContainer.api_unit1_temperatureLogic_channel4.string
        updates = updates + s"${bridge_id}_Out_unit1_pressureLogic_channel1" ~> postContainer.api_unit1_pressureLogic_channel1.string
        updates = updates + s"${bridge_id}_Out_unit1_pressureLogic_channel2" ~> postContainer.api_unit1_pressureLogic_channel2.string
        updates = updates + s"${bridge_id}_Out_unit1_pressureLogic_channel3" ~> postContainer.api_unit1_pressureLogic_channel3.string
        updates = updates + s"${bridge_id}_Out_unit1_pressureLogic_channel4" ~> postContainer.api_unit1_pressureLogic_channel4.string
        updates = updates + s"${bridge_id}_Out_unit1_saturationLogic_channel1" ~> postContainer.api_unit1_saturationLogic_channel1.string
        updates = updates + s"${bridge_id}_Out_unit1_saturationLogic_channel2" ~> postContainer.api_unit1_saturationLogic_channel2.string
        updates = updates + s"${bridge_id}_Out_unit1_saturationLogic_channel3" ~> postContainer.api_unit1_saturationLogic_channel3.string
        updates = updates + s"${bridge_id}_Out_unit1_saturationLogic_channel4" ~> postContainer.api_unit1_saturationLogic_channel4.string
        updates = updates + s"${bridge_id}_Out_unit2_temperatureLogic_channel1" ~> postContainer.api_unit2_temperatureLogic_channel1.string
        updates = updates + s"${bridge_id}_Out_unit2_temperatureLogic_channel2" ~> postContainer.api_unit2_temperatureLogic_channel2.string
        updates = updates + s"${bridge_id}_Out_unit2_temperatureLogic_channel3" ~> postContainer.api_unit2_temperatureLogic_channel3.string
        updates = updates + s"${bridge_id}_Out_unit2_temperatureLogic_channel4" ~> postContainer.api_unit2_temperatureLogic_channel4.string
        updates = updates + s"${bridge_id}_Out_unit2_pressureLogic_channel1" ~> postContainer.api_unit2_pressureLogic_channel1.string
        updates = updates + s"${bridge_id}_Out_unit2_pressureLogic_channel2" ~> postContainer.api_unit2_pressureLogic_channel2.string
        updates = updates + s"${bridge_id}_Out_unit2_pressureLogic_channel3" ~> postContainer.api_unit2_pressureLogic_channel3.string
        updates = updates + s"${bridge_id}_Out_unit2_pressureLogic_channel4" ~> postContainer.api_unit2_pressureLogic_channel4.string
        updates = updates + s"${bridge_id}_Out_unit2_saturationLogic_channel1" ~> postContainer.api_unit2_saturationLogic_channel1.string
        updates = updates + s"${bridge_id}_Out_unit2_saturationLogic_channel2" ~> postContainer.api_unit2_saturationLogic_channel2.string
        updates = updates + s"${bridge_id}_Out_unit2_saturationLogic_channel3" ~> postContainer.api_unit2_saturationLogic_channel3.string
        updates = updates + s"${bridge_id}_Out_unit2_saturationLogic_channel4" ~> postContainer.api_unit2_saturationLogic_channel4.string
        return updates
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_eventControlMock_eventControlMockThread_postInit =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[RTS.EventControl.EventControlMockThread_i_eventControlMock_eventControlMockThread_PostState_Container_PS]
        updates = updates + s"${bridge_id}_Out_manualActuatorInput1" ~> postContainer.api_manualActuatorInput1.string
        updates = updates + s"${bridge_id}_Out_manualActuatorInput2" ~> postContainer.api_manualActuatorInput2.string
        return updates
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuatorsMock_actuatorsMockThread_postInit =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[RTS.Actuators.ActuatorsMockThread_i_actuatorsMock_actuatorsMockThread_PostState_Container_PS]
        return updates
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_postInit =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[RTS.Actuation.CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_PostState_Container_PS]
        updates = updates + s"${bridge_id}_Out_actuate" ~> postContainer.api_actuate.string
        return updates
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_postInit =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[RTS.Actuation.CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_PostState_Container_PS]
        updates = updates + s"${bridge_id}_Out_actuate" ~> postContainer.api_actuate.string
        return updates
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_postInit =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[RTS.Actuation.CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_PostState_Container_PS]
        updates = updates + s"${bridge_id}_Out_actuate" ~> postContainer.api_actuate.string
        return updates
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_postInit =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[RTS.Actuation.OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_PostState_Container_PS]
        updates = updates + s"${bridge_id}_Out_actuate" ~> postContainer.api_actuate.string
        return updates
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_postInit =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[RTS.Actuation.CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_PostState_Container_PS]
        updates = updates + s"${bridge_id}_Out_actuate" ~> postContainer.api_actuate.string
        return updates
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_postInit =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[RTS.Actuation.CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_PostState_Container_PS]
        updates = updates + s"${bridge_id}_Out_actuate" ~> postContainer.api_actuate.string
        return updates
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_postInit =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[RTS.Actuation.CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_PostState_Container_PS]
        updates = updates + s"${bridge_id}_Out_actuate" ~> postContainer.api_actuate.string
        return updates
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_postInit =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[RTS.Actuation.OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_PostState_Container_PS]
        updates = updates + s"${bridge_id}_Out_actuate" ~> postContainer.api_actuate.string
        return updates
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_postInit =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[RTS.Actuation.OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_PostState_Container_PS]
        updates = updates + s"${bridge_id}_Out_actuate" ~> postContainer.api_actuate.string
        return updates
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_postInit =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[RTS.Actuation.Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_PostState_Container_PS]
        updates = updates + s"${bridge_id}_Out_output" ~> postContainer.api_output.string
        return updates
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_postInit =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[RTS.Actuation.OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_PostState_Container_PS]
        updates = updates + s"${bridge_id}_Out_actuate" ~> postContainer.api_actuate.string
        return updates
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_postInit =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[RTS.Actuation.Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_PostState_Container_PS]
        updates = updates + s"${bridge_id}_Out_output" ~> postContainer.api_output.string
        return updates
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_instrumentationMock_instrumentationMockThread_preCompute =>
        var updates: Map[String, String] = Map.empty
        val preContainer = container.asInstanceOf[RTS.Instrumentation.InstrumentationMockThread_i_instrumentationMock_instrumentationMockThread_PreState_Container_PS]
        return updates
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_eventControlMock_eventControlMockThread_preCompute =>
        var updates: Map[String, String] = Map.empty
        val preContainer = container.asInstanceOf[RTS.EventControl.EventControlMockThread_i_eventControlMock_eventControlMockThread_PreState_Container_PS]
        return updates
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuatorsMock_actuatorsMockThread_preCompute =>
        var updates: Map[String, String] = Map.empty
        val preContainer = container.asInstanceOf[RTS.Actuators.ActuatorsMockThread_i_actuatorsMock_actuatorsMockThread_PreState_Container_PS]
        updates = updates + s"${bridge_id}_In_tempPressureActuate" ~> preContainer.api_tempPressureActuate.string
        updates = updates + s"${bridge_id}_In_saturationActuate" ~> preContainer.api_saturationActuate.string
        return updates
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_preCompute =>
        var updates: Map[String, String] = Map.empty
        val preContainer = container.asInstanceOf[RTS.Actuation.CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_PreState_Container_PS]
        updates = updates + s"${bridge_id}_In_channel1" ~> preContainer.api_channel1.string
        updates = updates + s"${bridge_id}_In_channel2" ~> preContainer.api_channel2.string
        updates = updates + s"${bridge_id}_In_channel3" ~> preContainer.api_channel3.string
        updates = updates + s"${bridge_id}_In_channel4" ~> preContainer.api_channel4.string
        return updates
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_preCompute =>
        var updates: Map[String, String] = Map.empty
        val preContainer = container.asInstanceOf[RTS.Actuation.CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_PreState_Container_PS]
        updates = updates + s"${bridge_id}_In_channel1" ~> preContainer.api_channel1.string
        updates = updates + s"${bridge_id}_In_channel2" ~> preContainer.api_channel2.string
        updates = updates + s"${bridge_id}_In_channel3" ~> preContainer.api_channel3.string
        updates = updates + s"${bridge_id}_In_channel4" ~> preContainer.api_channel4.string
        return updates
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_preCompute =>
        var updates: Map[String, String] = Map.empty
        val preContainer = container.asInstanceOf[RTS.Actuation.CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_PreState_Container_PS]
        updates = updates + s"${bridge_id}_In_channel1" ~> preContainer.api_channel1.string
        updates = updates + s"${bridge_id}_In_channel2" ~> preContainer.api_channel2.string
        updates = updates + s"${bridge_id}_In_channel3" ~> preContainer.api_channel3.string
        updates = updates + s"${bridge_id}_In_channel4" ~> preContainer.api_channel4.string
        return updates
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_preCompute =>
        var updates: Map[String, String] = Map.empty
        val preContainer = container.asInstanceOf[RTS.Actuation.OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_PreState_Container_PS]
        updates = updates + s"${bridge_id}_In_channel1" ~> preContainer.api_channel1.string
        updates = updates + s"${bridge_id}_In_channel2" ~> preContainer.api_channel2.string
        return updates
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_preCompute =>
        var updates: Map[String, String] = Map.empty
        val preContainer = container.asInstanceOf[RTS.Actuation.CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_PreState_Container_PS]
        updates = updates + s"${bridge_id}_In_channel1" ~> preContainer.api_channel1.string
        updates = updates + s"${bridge_id}_In_channel2" ~> preContainer.api_channel2.string
        updates = updates + s"${bridge_id}_In_channel3" ~> preContainer.api_channel3.string
        updates = updates + s"${bridge_id}_In_channel4" ~> preContainer.api_channel4.string
        return updates
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_preCompute =>
        var updates: Map[String, String] = Map.empty
        val preContainer = container.asInstanceOf[RTS.Actuation.CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_PreState_Container_PS]
        updates = updates + s"${bridge_id}_In_channel1" ~> preContainer.api_channel1.string
        updates = updates + s"${bridge_id}_In_channel2" ~> preContainer.api_channel2.string
        updates = updates + s"${bridge_id}_In_channel3" ~> preContainer.api_channel3.string
        updates = updates + s"${bridge_id}_In_channel4" ~> preContainer.api_channel4.string
        return updates
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_preCompute =>
        var updates: Map[String, String] = Map.empty
        val preContainer = container.asInstanceOf[RTS.Actuation.CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_PreState_Container_PS]
        updates = updates + s"${bridge_id}_In_channel1" ~> preContainer.api_channel1.string
        updates = updates + s"${bridge_id}_In_channel2" ~> preContainer.api_channel2.string
        updates = updates + s"${bridge_id}_In_channel3" ~> preContainer.api_channel3.string
        updates = updates + s"${bridge_id}_In_channel4" ~> preContainer.api_channel4.string
        return updates
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_preCompute =>
        var updates: Map[String, String] = Map.empty
        val preContainer = container.asInstanceOf[RTS.Actuation.OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_PreState_Container_PS]
        updates = updates + s"${bridge_id}_In_channel1" ~> preContainer.api_channel1.string
        updates = updates + s"${bridge_id}_In_channel2" ~> preContainer.api_channel2.string
        return updates
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_preCompute =>
        var updates: Map[String, String] = Map.empty
        val preContainer = container.asInstanceOf[RTS.Actuation.OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_PreState_Container_PS]
        updates = updates + s"${bridge_id}_In_channel1" ~> preContainer.api_channel1.string
        updates = updates + s"${bridge_id}_In_channel2" ~> preContainer.api_channel2.string
        return updates
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_preCompute =>
        var updates: Map[String, String] = Map.empty
        val preContainer = container.asInstanceOf[RTS.Actuation.Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_PreState_Container_PS]
        updates = updates + s"${bridge_id}_In_input" ~> preContainer.api_input.string
        updates = updates + s"${bridge_id}_In_manualActuatorInput" ~> preContainer.api_manualActuatorInput.string
        return updates
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_preCompute =>
        var updates: Map[String, String] = Map.empty
        val preContainer = container.asInstanceOf[RTS.Actuation.OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_PreState_Container_PS]
        updates = updates + s"${bridge_id}_In_channel1" ~> preContainer.api_channel1.string
        updates = updates + s"${bridge_id}_In_channel2" ~> preContainer.api_channel2.string
        return updates
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_preCompute =>
        var updates: Map[String, String] = Map.empty
        val preContainer = container.asInstanceOf[RTS.Actuation.Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_PreState_Container_PS]
        updates = updates + s"${bridge_id}_In_input" ~> preContainer.api_input.string
        updates = updates + s"${bridge_id}_In_manualActuatorInput" ~> preContainer.api_manualActuatorInput.string
        return updates
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_instrumentationMock_instrumentationMockThread_postCompute =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[RTS.Instrumentation.InstrumentationMockThread_i_instrumentationMock_instrumentationMockThread_PostState_Container_PS]
        updates = updates + s"${bridge_id}_Out_unit1_temperatureLogic_channel1" ~> postContainer.api_unit1_temperatureLogic_channel1.string
        updates = updates + s"${bridge_id}_Out_unit1_temperatureLogic_channel2" ~> postContainer.api_unit1_temperatureLogic_channel2.string
        updates = updates + s"${bridge_id}_Out_unit1_temperatureLogic_channel3" ~> postContainer.api_unit1_temperatureLogic_channel3.string
        updates = updates + s"${bridge_id}_Out_unit1_temperatureLogic_channel4" ~> postContainer.api_unit1_temperatureLogic_channel4.string
        updates = updates + s"${bridge_id}_Out_unit1_pressureLogic_channel1" ~> postContainer.api_unit1_pressureLogic_channel1.string
        updates = updates + s"${bridge_id}_Out_unit1_pressureLogic_channel2" ~> postContainer.api_unit1_pressureLogic_channel2.string
        updates = updates + s"${bridge_id}_Out_unit1_pressureLogic_channel3" ~> postContainer.api_unit1_pressureLogic_channel3.string
        updates = updates + s"${bridge_id}_Out_unit1_pressureLogic_channel4" ~> postContainer.api_unit1_pressureLogic_channel4.string
        updates = updates + s"${bridge_id}_Out_unit1_saturationLogic_channel1" ~> postContainer.api_unit1_saturationLogic_channel1.string
        updates = updates + s"${bridge_id}_Out_unit1_saturationLogic_channel2" ~> postContainer.api_unit1_saturationLogic_channel2.string
        updates = updates + s"${bridge_id}_Out_unit1_saturationLogic_channel3" ~> postContainer.api_unit1_saturationLogic_channel3.string
        updates = updates + s"${bridge_id}_Out_unit1_saturationLogic_channel4" ~> postContainer.api_unit1_saturationLogic_channel4.string
        updates = updates + s"${bridge_id}_Out_unit2_temperatureLogic_channel1" ~> postContainer.api_unit2_temperatureLogic_channel1.string
        updates = updates + s"${bridge_id}_Out_unit2_temperatureLogic_channel2" ~> postContainer.api_unit2_temperatureLogic_channel2.string
        updates = updates + s"${bridge_id}_Out_unit2_temperatureLogic_channel3" ~> postContainer.api_unit2_temperatureLogic_channel3.string
        updates = updates + s"${bridge_id}_Out_unit2_temperatureLogic_channel4" ~> postContainer.api_unit2_temperatureLogic_channel4.string
        updates = updates + s"${bridge_id}_Out_unit2_pressureLogic_channel1" ~> postContainer.api_unit2_pressureLogic_channel1.string
        updates = updates + s"${bridge_id}_Out_unit2_pressureLogic_channel2" ~> postContainer.api_unit2_pressureLogic_channel2.string
        updates = updates + s"${bridge_id}_Out_unit2_pressureLogic_channel3" ~> postContainer.api_unit2_pressureLogic_channel3.string
        updates = updates + s"${bridge_id}_Out_unit2_pressureLogic_channel4" ~> postContainer.api_unit2_pressureLogic_channel4.string
        updates = updates + s"${bridge_id}_Out_unit2_saturationLogic_channel1" ~> postContainer.api_unit2_saturationLogic_channel1.string
        updates = updates + s"${bridge_id}_Out_unit2_saturationLogic_channel2" ~> postContainer.api_unit2_saturationLogic_channel2.string
        updates = updates + s"${bridge_id}_Out_unit2_saturationLogic_channel3" ~> postContainer.api_unit2_saturationLogic_channel3.string
        updates = updates + s"${bridge_id}_Out_unit2_saturationLogic_channel4" ~> postContainer.api_unit2_saturationLogic_channel4.string
        return updates
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_eventControlMock_eventControlMockThread_postCompute =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[RTS.EventControl.EventControlMockThread_i_eventControlMock_eventControlMockThread_PostState_Container_PS]
        updates = updates + s"${bridge_id}_Out_manualActuatorInput1" ~> postContainer.api_manualActuatorInput1.string
        updates = updates + s"${bridge_id}_Out_manualActuatorInput2" ~> postContainer.api_manualActuatorInput2.string
        return updates
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuatorsMock_actuatorsMockThread_postCompute =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[RTS.Actuators.ActuatorsMockThread_i_actuatorsMock_actuatorsMockThread_PostState_Container_PS]
        return updates
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_postCompute =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[RTS.Actuation.CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_PostState_Container_PS]
        updates = updates + s"${bridge_id}_Out_actuate" ~> postContainer.api_actuate.string
        return updates
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_postCompute =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[RTS.Actuation.CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_PostState_Container_PS]
        updates = updates + s"${bridge_id}_Out_actuate" ~> postContainer.api_actuate.string
        return updates
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_postCompute =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[RTS.Actuation.CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_PostState_Container_PS]
        updates = updates + s"${bridge_id}_Out_actuate" ~> postContainer.api_actuate.string
        return updates
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_postCompute =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[RTS.Actuation.OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_PostState_Container_PS]
        updates = updates + s"${bridge_id}_Out_actuate" ~> postContainer.api_actuate.string
        return updates
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_postCompute =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[RTS.Actuation.CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_PostState_Container_PS]
        updates = updates + s"${bridge_id}_Out_actuate" ~> postContainer.api_actuate.string
        return updates
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_postCompute =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[RTS.Actuation.CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_PostState_Container_PS]
        updates = updates + s"${bridge_id}_Out_actuate" ~> postContainer.api_actuate.string
        return updates
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_postCompute =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[RTS.Actuation.CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_PostState_Container_PS]
        updates = updates + s"${bridge_id}_Out_actuate" ~> postContainer.api_actuate.string
        return updates
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_postCompute =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[RTS.Actuation.OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_PostState_Container_PS]
        updates = updates + s"${bridge_id}_Out_actuate" ~> postContainer.api_actuate.string
        return updates
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_postCompute =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[RTS.Actuation.OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_PostState_Container_PS]
        updates = updates + s"${bridge_id}_Out_actuate" ~> postContainer.api_actuate.string
        return updates
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_postCompute =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[RTS.Actuation.Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_PostState_Container_PS]
        updates = updates + s"${bridge_id}_Out_output" ~> postContainer.api_output.string
        return updates
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_postCompute =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[RTS.Actuation.OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_PostState_Container_PS]
        updates = updates + s"${bridge_id}_Out_actuate" ~> postContainer.api_actuate.string
        return updates
      case RTS.runtimemonitor.ObservationKind.RTS_i_Instance_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_postCompute =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[RTS.Actuation.Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_PostState_Container_PS]
        updates = updates + s"${bridge_id}_Out_output" ~> postContainer.api_output.string
        return updates
      case _ => return Map.empty
    }
  }
}