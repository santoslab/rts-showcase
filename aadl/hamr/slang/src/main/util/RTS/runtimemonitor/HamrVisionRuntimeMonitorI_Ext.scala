package RTS.runtimemonitor

import art.scheduling.static._
import art.{Art, DataContent}
import org.sireum.$internal.MutableMarker
import org.sireum._
import org.sireum.hamr.vision.treetable.{Category, Entry, JTreeTable, Row => hvRow}
import org.sireum.hamr.vision.value.{StringValue, Value}

import java.awt.{BorderLayout, Dimension, GridBagConstraints, GridBagLayout}
import java.util.concurrent.{Executors, LinkedBlockingDeque, TimeUnit}
import javax.swing._
import scala.concurrent.{ExecutionContext, ExecutionContextExecutorService, Future}
import scala.jdk.CollectionConverters._

// Do not edit this file as it will be overwritten if HAMR codegen is rerun

object HamrVisionRuntimeMonitorI_Ext {
  def getCommandProvider(): CommandProvider = {
    return new HamrVisionCommandProvider()
  }
}

class HamrVisionCommandProvider extends JPanel with InfoCommandProvider {

  var threadNickNames: Map[String, art.Art.BridgeId] = Map.empty

  var numSlots: Z = 0

  var displayOrder: ISZ[Art.BridgeId] = IS()

  var clearColorsCallback: () => Unit = _

  val blockingQueue: LinkedBlockingDeque[Command] = new LinkedBlockingDeque[Command](1)

  val jlNextThread = new JLabel()
  val jlSlot = new JLabel()
  val jlDomain = new JLabel()
  val jlHyperPeriod = new JLabel()

  var lastHP = z"0"
  var cleared: B = F

  def init(threadNickNames: Map[String, Art.BridgeId],
           numSlots: Z,
           displayOrder: ISZ[Art.BridgeId]): CommandProvider = {
    this.threadNickNames = threadNickNames
    this.numSlots = numSlots
    this.displayOrder = displayOrder

    var y = 0
    var x = 0
    val gbc = new GridBagConstraints()

    def gadd(panel: JComponent, jcomponent: JComponent): Unit = {
      gbc.gridy = y
      gbc.gridx = x
      gbc.anchor = if (x == 0) GridBagConstraints.EAST else GridBagConstraints.WEST
      panel.add(jcomponent, gbc)
      y = y + x
      x = (x + 1) % 2
    }

    val leftPanel = new JPanel()

    {
      x = 0
      y = 0

      leftPanel.setLayout(new GridBagLayout())

      val spnHStep = new JSpinner(new SpinnerNumberModel(1, 1, 100, 1))

      val btnHStep: JButton = new JButton("Hyper period Step")
      btnHStep.addActionListener(e => {
        val numSteps = Z(spnHStep.getValue.string).get
        blockingQueue.offer(Hstep(numSteps), 100, TimeUnit.MILLISECONDS)
      })
      gadd(leftPanel, btnHStep)
      gadd(leftPanel, spnHStep)

      val spnSstep = new JSpinner(new SpinnerNumberModel(1, 1, 100, 1))

      val btnSstep: JButton = new JButton("Slot Step")
      btnSstep.addActionListener(e => {
        val numSteps = Z(spnSstep.getValue.string).get
        blockingQueue.offer(Sstep(numSteps), 100, TimeUnit.MILLISECONDS)
      })
      gadd(leftPanel, btnSstep)
      gadd(leftPanel, spnSstep)

      val nickOrder: ISZ[Predef.String] = {
        val rev: Map[art.Art.BridgeId, String] = Map.empty ++ (for (e <- threadNickNames.entries) yield e._2 ~> e._1)
        var ret: ISZ[Predef.String] = ISZ()
        for(i <- displayOrder) {
          rev.get(i) match {
            case Some(k) => ret = ret :+ k.string.native
            case _ => ret = ret :+ i.string.native
          }
        }
        ret
      }
      val cmbThreads = new JComboBox[Predef.String](new java.util.Vector(nickOrder.elements.asJava))
      cmbThreads.setSelectedIndex(0)
      val btnRunToThread = new JButton("Run To Thread")
      btnRunToThread.addActionListener(e => {
        val thread = cmbThreads.getSelectedItem.asInstanceOf[Predef.String]
        blockingQueue.offer(RunToThread(thread))
      })
      gadd(leftPanel, btnRunToThread)
      gadd(leftPanel, cmbThreads)
    }

    val rightPanel = new JPanel()

    {
      val rightLayout = new GridBagLayout()
      rightPanel.setLayout(rightLayout)

      y = 0
      x = 0

      gadd(rightPanel, new JLabel("Hyper Period: "))
      gadd(rightPanel, jlHyperPeriod)

      gadd(rightPanel, new JLabel("Slot: "))
      gadd(rightPanel, jlSlot)

      //gadd(rightPanel, new JLabel("Domain: "))
      //gadd(rightPanel, jlDomain)

      gadd(rightPanel, new JLabel("Next Thread: "))
      gadd(rightPanel, jlNextThread)

    }
    val panel = new JPanel(new GridBagLayout())
    x = 0
    y = 0
    gadd(panel, leftPanel)
    gadd(panel, rightPanel)

    // add some dummy spacers to try and get left and right panels to
    // always be in the exactly in the middle
    val spacer = new JPanel()
    spacer.setPreferredSize(new Dimension(600, 1))
    val spacer2 = new JPanel()
    spacer2.setPreferredSize(new Dimension(600, 1))
    gadd(panel, spacer)
    gadd(panel, spacer2)

    this.add(panel, BorderLayout.CENTER)

    return this
  }

  override def nextCommand(): Command = {
    val s = Explorer.scheduleState
    jlHyperPeriod.setText(s.hyperperiodNum.string.native)
    jlSlot.setText(s.slotNum.string.native)
    jlDomain.setText(Schedule.getDomainFromScheduleState(s).string.native)
    jlNextThread.setText(Schedule.getThreadNickNameFromScheduleState(s).native)

    val nextHP = s.hyperperiodNum
    if (lastHP != nextHP) {
      clearColorsCallback()
      lastHP = nextHP
    }
    return blockingQueue.take()
  }

  override def string: String = toString

  override def $clonable: Boolean = F

  override def $clonable_=(b: Boolean): MutableMarker = this

  override def $owned: Boolean = F

  override def $owned_=(b: Boolean): MutableMarker = this

  override def $clone: MutableMarker = this
}

class HamrVisionRuntimeMonitor(cp: MOption[CommandProvider]) extends RuntimeMonitorListener {

  var visionTreeTable: JTreeTable = _

  def clearColors(): Unit = {
    visionTreeTable.clearColor()
  }

  def modelInfoEntry(modelInfo: ModelInfo): ISZ[Entry] = {
    val revMap: Map[art.Art.BridgeId, String] = cp match {
      case MSome(i: InfoCommandProvider) => Map.empty ++ (for (e <- i.threadNickNames.entries) yield (e._2, e._1))
      case _ => Map.empty
    }

    val orderComponents: ISZ[Component] =
      cp match {
        case MSome(i: InfoCommandProvider) =>
          if (i.displayOrder.nonEmpty) {
            val map = Map.empty ++ (for (c <- modelInfo.components) yield (art.Art.BridgeId.fromZ(c.id), c))
            val uniqueIds = Set.empty[art.Art.BridgeId]() ++ i.displayOrder
            for (id <- uniqueIds.elements) yield map.get(id).get
          } else {
            modelInfo.components
          }
        case _ => modelInfo.components
      }

    var components: ISZ[Entry] = ISZ()

    for (c <- orderComponents) {
      var inputs: ISZ[Entry] = ISZ()
      var outputs: ISZ[Entry] = ISZ()

      for (state <- c.state) {
        val kind: String = state match {
          case i: Port =>
            s"${if (state.direction == StateDirection.In) "Incoming" else "Outgoing"} Port"
          case i: StateVariable =>
            s"${if (state.direction == StateDirection.In) "Pre" else "Post"} State Variable"
        }
        val id = s"${c.id}_${state.direction}_${state.name}"
        state.direction match {
          case StateDirection.In =>
            inputs = inputs :+
              hvRow(rowId = id.string, values = ISZ(StringValue(state.name), StringValue(kind), StringValue("")))
          case StateDirection.Out =>
            outputs = outputs :+
              hvRow(rowId = id.string, values = ISZ(StringValue(state.name), StringValue(kind), StringValue("")))
        }
      }
      val componentName: String = revMap.get(art.Art.BridgeId.fromZ(c.id)) match {
        case Some(nick) => nick
        case _ => c.name
      }
      var children: ISZ[Entry] = ISZ()
      if (inputs.nonEmpty) {
        children = children :+ Category(displayName = "Inputs", children = inputs)
      }
      if (outputs.nonEmpty) {
        children = children :+ Category(displayName = "Outputs", children = outputs)
      }
      components = components :+ Category(displayName = componentName, children = children)
    }
    return components
  }

  override def init(modelInfo: ModelInfo): Unit = {
    val entries = modelInfoEntry(modelInfo)
    visionTreeTable = new JTreeTable(entries, ISZ("State Element", "Description", "Value"))

    val visionFrame = new JFrame()
    val visionPane = new JScrollPane(visionTreeTable)
    visionFrame.add(visionPane, BorderLayout.CENTER)
    cp match {
      case MSome(i: HamrVisionCommandProvider) =>
        visionFrame.add(i, BorderLayout.SOUTH)
        i.clearColorsCallback = clearColors _
      case MSome(x) => halt(s"Not expecting $x")
      case _ =>
    }
    visionFrame.setTitle("HAMR Vision Runtime Monitor")
    visionFrame.pack()
    visionFrame.setSize(new java.awt.Dimension(800, 600))
    visionFrame.setVisible(true)
  }

  def updateOutPorts(bridge: art.Art.BridgeId, observationKind: ObservationKind.Type, post: art.DataContent): Unit = {
    val m: Map[String, String] = GumboXDispatcher.getUpdates(bridge, observationKind, post)
    for (entry <- m.entries) {
      visionTreeTable.update(entry._1, ISZ[Option[Value]](None(), None(), Some(StringValue(entry._2))))
    }
  }

  def updateInPorts(bridge: art.Art.BridgeId, observationKind: ObservationKind.Type, pre: art.DataContent): Unit = {
    val m: Map[String, String] = GumboXDispatcher.getUpdates(bridge, observationKind, pre)
    for (entry <- m.entries) {
      visionTreeTable.update(entry._1, ISZ[Option[Value]](None(), None(), Some(StringValue(entry._2))))
    }
  }

  protected implicit val context: ExecutionContextExecutorService = ExecutionContext.fromExecutorService(Executors.newSingleThreadExecutor())

  override def observeInitialisePostState(bridgeId: Art.BridgeId, observationKind: ObservationKind.Type, post: DataContent): Unit = {
    Future(updateOutPorts(bridgeId, observationKind, post))
  }

  override def observeComputePreState(bridgeId: Art.BridgeId, observationKind: ObservationKind.Type, pre: Option[DataContent]): Unit = {
    // TODO: really want to run updates in a separate, non-blocking thread. HamrVision should not block
    //       the Slang program, nor any other running swing GUI -- I don't think SwingUtilities.invokeLater
    //       guarantees the latter
    Future(updateInPorts(bridgeId, observationKind, pre.get))
  }

  override def observeComputePrePostState(bridgeId: Art.BridgeId, observationKind: ObservationKind.Type, pre: Option[DataContent], post: DataContent): Unit = {
    Future(updateOutPorts(bridgeId, observationKind, post))
  }

  override def string: String = toString

  override def finalise(): Unit = {}

  override def $clonable: Boolean = F

  override def $clonable_=(b: Boolean): MutableMarker = this

  override def $owned: Boolean = F

  override def $owned_=(b: Boolean): MutableMarker = this

  override def $clone: MutableMarker = this
}